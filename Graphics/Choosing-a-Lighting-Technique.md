# 选择照明技术
从广义上讲，Unity中的照明可以被视为“Realtime（实时）”或“precomputed”（预先计算），并且两种技术可以组合使用以创建沉浸式场景照明。

在本节中，将对这两种不同的技术所带来的机遇做一个概述，讲解它们相应的优势和自身的性能特点

## Realtime Lighting（实时光照）
默认情况下，Unity中的灯光 - directional, spot 和 point，均是实时光。这意味着它们为场景提供直射光并在每一帧都会更新。当灯光和游戏对象在场景中移动时，灯光将立即更新。这可以在场景和游戏视图中观察到。

![](/Image/Graphics/Introduction/realtime_0.png)

*单独使用实时光的效果。请注意，阴影是完全黑色的，因为没有反射光。只有落在聚光灯锥体内的表面才会受到影响。*

实时照明是场景中照明对象的最基本方式，对于照亮角色或其他可移动几何体非常有用。

不幸的是，**来自Unity的实时灯光的光线~~在只使用它们自身时~~不会进行反射计算**（the light rays from Unity’s realtime lights do not bounce when they are used by themselves）。为了使用全局照明等技术创建更逼真的场景，我们需要启用Unity的预计算照明解决方案。

## Baked GI Lighting（烘培全局光照）
当**烘培**了**光照贴图**后，在场景内的所有静态物体上的光照特效都将进行计算，而计算结果也会被覆写在场景内几何体的表面用于创建光照特效。

![](/Image/Graphics/Introduction/lightmap.jpg)

*左图：一个简单的光照场景。右图：Unity创建的光照贴图。注意阴影和光线信息是如何被捕捉的。*

这些**光照贴图**不仅包含了直射在物体表面的光线，还包含从场景中其他物体表面反射而来的间接光线。这些光照贴图可以和像颜色（albedo），法线（normal）这样的通过Shader的来自于物体材质表面信息一同使用。

通过烘培光照，这些光照贴图不能再游戏运行时改变，也正是所谓的静态（Static）。实时光照可以被覆盖或是在已经做过光照烘培的场景上进行叠加使用，但是不能改变已经烘培好的光照贴图。

通过烘培全局光照的方法，我们牺牲了在游戏中移动光源的能力换取了性能上的提升，这在像移动端这样硬件性能较低的设备上十分有效。

## Precomputed Realtime GI Lighting（实时全局光照预计算）

传统的静态光照贴图不能反应场景内光照条件的变化，实时全局光照预计算（Precomputed Realtime GI）将提供我们一个用于更新复杂场景光照的技术。

通过这个技术，可以创建具有丰富全局照明和反射光的照明环境，并实时响应照明变化。其中最合适的例子就是一个时间系统，在该场景中，光源的颜色与位置随时而变。如果只使用传统的烘培光照是不可能完成的。

![](/Image/Graphics/Introduction/timeofdaycycle.gif)

*使用实时全局光照预计算的时间场景*

为了以可播放的帧率来显示这些效果，我们需要将一些冗长的数字运算从实时过程转移到“预先计算”的过程。

预计算将处理复杂光照的任务从游戏运行时计算转移到时间不紧张时再计算。我们将此称为**离线**过程。

那么它是如何运行的呢？

在我们为了创建一个真实的场景光照时，想要存进光照贴图的光线中最常见的就是间接（反射）光线。幸运的是，这些在颜色上的变化都是十分平缓的（没有高频率的变化）。Unity的实时全局光照预计算（Precomputed Realtime GI ）方案就是利用这些间接光照的漫反射特性给我们带来便利。

像清晰的阴影这样的光照细节，通常使用实时光照而不是烘培进光照贴图的方式。假设我们不需要捕捉这些复杂的细节，我们可以大大降低我们全局光照方案的难度。

通过在预计算期间进行简化操作，我们有效地减少了用于游戏过程中更新GI照明的计算次数。在我们要更改灯光的属性（例如颜色，旋转或强度），甚至更改场景中的物体表面结构时，有着重大的意义。

为了进一步加快预计算，Unity不会直接处理光照贴图像素，而是创建一个低分辨率的静态几何体近似，称为“clusters”。

![](/Image/Graphics/Introduction/albedo.png)

*左：在场景视图设置为“Albedo”的情况下，可以清楚地看到Unity的预计算实时GI生成的纹素。默认情况下，此视图中的纹素大致与cluster的大小相同。右图：一旦计算了光照并将结果转换为光照贴图纹理并应用，就会出现在游戏中的场景。*

通常我们计算全局光照时，我们会对在静态场景内反射的光线进行光线追踪（Ray Trace）。这项操作是十分复杂的，因而如果要求实时更新计算是十分苛刻的。作为替代，Unity会预先，在预计算的“Light Transport”部分，使用光线追踪来计算这些表面clusters的相互关系。

通过将虚拟世界简化成关系网，我们就可以将昂贵的光线追踪需求从性能吃紧的运行过程中移除。

我们已经高效地创建了一个虚拟世界的简化数学模型，这可以用来在运行时提供不同的输入参数。这也意味着我们可以对场景内灯光、表面颜色进行修改，并可以看到每帧更新的场景内的全局光照效果。我们光照模型的输出结果可以被转换成用于GPU渲染的光照贴图，在于其他光照和表面贴图混合，处理效果后输出在屏幕上。

## Benefits and Costs（收益与成本）

虽然可以同时使用Baked GI照明和Precomputed Realtime GI，但要注意，同时使用两个系统进行渲染所带来的的性能成本恰好是它们的总和。我们不仅需要在显存中存储两组光照贴图，而且还要在着色器中支付解码的处理成本。

您可能希望选择一种照明方法而非另一种照明方法的情况取决于项目的性质和预期硬件的性能。例如，在视频存储器和处理能力更受限制的移动设备上，Baked GI照明方法可能更具性能。在具有专用图形硬件或最新游戏控制台的“独立计算机”上，很有可能使用预计算实时GI甚至同时使用两个系统。

必须根据您的特定项目需求和所需目标平台的性质来决定采用哪种方法。请记住，在针对一系列不同硬件时，通常情况下，其中性能最低参数的将决定需要哪种方法。

## Enabling Baked GI or Precomputed Realtime GI（启用烘焙GI或预先计算的实时GI）
默认情况下，Unity的“Lighting”面板（Lighting-Scene）中启用了预计算实时GI和烘焙GI。启用后，可以使用哪种技术单独控制每个灯（Inspector-Light-Baking）。

在场景中同时使用Baked GI和预先计算的实时GI可能会对性能产生不利影响。一个好的做法是通过全局禁用另一个系统来确保一次只使用一个系统。这可以通过取消选中Unity的照明面板（Lighting> Scene）中预先计算的实时GI或Baked GI旁边的框来完成。现在，只有选中的选项将出现在场景中，并且将覆盖为每个灯光配置的所有设置。

## （Per-Light Settings）灯光设置
每个灯的默认烘焙模式是“Realtime（实时）”。这意味着所选择的灯仍将为您的场景提供直射光，Unity的预计算实时GI系统可以处理间接光。

但是，如果将烘焙模式设置为“Baked（烘焙）”，那么该光将仅为Unity的Baked GI系统提供照明。来自所选灯光的直接和间接光线将被“烘焙”到光照贴图中，并且在游戏过程中无法更改。

![](/Image/Graphics/Introduction/lightbakingmode_2.png)

*灯光的烘培模式设置为“Realtime（实时）”的点光源。*

选择“混合”烘焙模式，标记为静态的GameObjects仍会在其Baked GI光照贴图中包含此光。但是，与标记为“Baked”的灯不同，混合灯仍然会为场景中的非静态GameObject提供实时直接光源。这在您在静态环境中使用光照贴图，又同时希望角色使用这些相同的灯光将实时阴影投射到光照贴图的几何体上的情况下非常有用。

[返回上一级](/Graphics/Introduction-to-Lighting-and-Rendering.md)

[返回主页](/README.md)
